<?php
/*
 * This file has been automatically generated by TDBM.
 * You can edit this file as it will not be overwritten.
 */

declare(strict_types=1);

namespace App\Infrastructure\Dao;

use App\Domain\Enum\UserTypeEnum;
use App\Domain\Exception\NotFound;
use App\Domain\Model\User;
use App\Domain\Repository\UserRepository;
use App\Infrastructure\Dao\Generated\AbstractUserDao;
use App\Infrastructure\Logging\ModelLogger;
use Symfony\Component\Security\Core\Authentication\Token\Storage\TokenStorageInterface;
use TheCodingMachine\TDBM\ResultIterator;
use TheCodingMachine\TDBM\TDBMService;
use function count;
use function explode;

/**
 * The UserDao class will maintain the persistence of User class into the users table.
 */
class UserDao extends AbstractUserDao implements UserRepository
{
    use ModelLogger;

    public const SORT_COLUMNS = [
        'name' => 'last_name',
        'createdAt' => 'users.created_at',
        'status' => 'status',
    ];

    private TokenStorageInterface $tokenStorage;

    public function __construct(TDBMService $tdbmService, TokenStorageInterface $tokenStorage)
    {
        $this->tokenStorage = $tokenStorage;
        parent::__construct($tdbmService);
    }

    /**
     * @param String[] $filters
     * @param String[] $params
     */
    private function userTypeFilter(array &$filters, array &$params): void
    {
        $userType = $this->getLoggedUser()->getType()->getId();

        switch ($userType) {
            case UserTypeEnum::COACH:
                $filters[] = 'coach_id = :coach';
                $params['coach'] = $this->getLoggedUser()->getId();
                break;
        }
    }

    protected function getTokenStorage(): TokenStorageInterface
    {
        return $this->tokenStorage;
    }

    protected function getUserRepository(): UserRepository
    {
        return $this;
    }

    public function save(User $user): void
    {
        $this->log($user);
        parent::save($user);
    }

    public function saveNoLog(User $user): void
    {
        parent::save($user);
    }

    /**
     * @throws NotFound
     */
    public function mustFindOneById(string $id): User
    {
        $user = $this->findOne(['id' => $id]);
        if ($user === null) {
            throw new NotFound(User::class, ['id' => $id]);
        }

        return $user;
    }

    /**
     * @return User[]|ResultIterator
     */
    public function findByFilters(?string $search = null, ?string $companyName = null, bool $coachesOnly = false, ?string $roleId = null, ?string $companyId = null, ?string $sortColumn = null, ?string $sortDirection = null): ResultIterator
    {
        $query = 'users JOIN users_roles ON users.id = users_roles.user_id';

        $filters = ['users.deleted = 0'];
        $parameter = [];

        if (! empty($search)) {
            $searchValues = explode(' ', $search);
            $filtersTmp = '(';
            foreach ($searchValues as $key => $value) {
                $filtersTmp .= 'first_name LIKE :champ' . $key . ' OR last_name LIKE :champ' . $key . ' OR email LIKE :champ' . $key;
                $parameter['champ' . $key] = '%' . $value . '%';

                if ($key === count($searchValues) - 1) {
                    continue;
                }

                $filtersTmp .= ' OR ';
            }
            $filtersTmp .= ')';
            $filters[] = $filtersTmp;
        }

        if (! empty($companyName) && empty($companyId)) {
            $filters[] = 'companies.name LIKE :company';
            $query .= ' JOIN companies ON users.company_id = companies.id';
            $parameter['company'] = '%' . $companyName . '%';
        }

        if (! empty($companyId)) {
            $filters[] = 'company_id = :company';
            $parameter['company'] = $companyId;
        }

        if (! empty($roleId)) {
            $filters[] = 'users_roles.role_id=:role';
            $parameter['role'] = $roleId;
        }

        if ($coachesOnly) {
            $filters[] = 'type = :type';
            $parameters['type'] = UserTypeEnum::COACH;
        }

        $orderBy = null;
        if (! empty($sortColumn) && isset(self::SORT_COLUMNS[$sortColumn])) {
            $orderBy = self::SORT_COLUMNS[$sortColumn] . ' ' . ($sortDirection === 'asc' ? 'ASC' : 'DESC');
        }

        $this->userTypeFilter($filters, $parameter);

        return $this->findFromSql($query, $filters, $parameter, $orderBy);
    }

    public function getLoggedUser(): User
    {
        return $this->_getUser();
    }

    /**
     * Checks if the given email is unique. Using findOneByEmail has significant overhead which we do not need for simple
     * input validation
     */
    public function checkEmailUnique(string $email, ?string $userId = null): bool
    {
        $query = $this->tdbmService->getConnection()->executeQuery('
            SELECT id FROM users
            WHERE email = :email' . ($userId !== null ? ' AND id != :userId' : '') . '
            LIMIT 1
        ', ['email' => $email, 'userId' => $userId]);

        return count($query->fetchAll()) === 0;
    }
}
